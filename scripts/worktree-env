#!/usr/bin/env bash
set -euo pipefail

port_in_use() {
  lsof -nP -iTCP:"$1" -sTCP:LISTEN &>/dev/null
}

if [[ -z "${WM_SLOT:-}" ]]; then
  # Scan .env.local files of existing worktrees to find which slots are claimed,
  # then pick the lowest free slot. This avoids collisions when worktrees are
  # removed and new ones created (position-based indexing would re-use slots
  # still held by surviving worktrees).
  used_slots=()
  current_dir="$(pwd)"
  while IFS= read -r wt_path; do
    [[ "$wt_path" == "$current_dir" ]] && continue
    if [[ -f "$wt_path/.env.local" ]]; then
      bp=$(grep '^BACKEND_PORT=' "$wt_path/.env.local" | cut -d= -f2 || true)
      if [[ -n "$bp" && "$bp" -gt 8000 ]]; then
        used_slots+=("$(( (bp - 8000) / 10 ))")
      fi
    fi
  done < <(git worktree list --porcelain | sed -n 's/^worktree //p')

  # Find lowest available slot (slot 0 = 8000/3000 is reserved for main)
  WM_SLOT=1
  while [[ " ${used_slots[*]:-} " == *" $WM_SLOT "* ]]; do
    ((WM_SLOT++))
  done
  echo "Auto-assigned slot $WM_SLOT (used: ${used_slots[*]:-none})"
fi

# Slot-based: predictable ports for SSH forwarding
# Slot 0 = 8000/3000, slot 1 = 8010/3010, slot 2 = 8020/3020, etc.
backend_port=$((8000 + WM_SLOT * 10))
frontend_port=$((3000 + WM_SLOT * 10))

if port_in_use "$backend_port" || port_in_use "$frontend_port"; then
  echo "WARNING: Slot $WM_SLOT ports ($backend_port/$frontend_port) already in use" >&2
fi

# Generate .env.local with port overrides
cat > .env.local <<EOF
BACKEND_PORT=$backend_port
FRONTEND_PORT=$frontend_port
REMOTE=http://localhost:$backend_port
EOF

if [[ -n "${CARGO_FEATURES:-}" ]]; then
  echo "CARGO_FEATURES=$CARGO_FEATURES" >> .env.local
fi

echo "Created .env.local with ports: backend=$backend_port, frontend=$frontend_port"

# --- Copy frontend/node_modules preserving symlinks ---
# cp -a preserves .bin/ symlinks that cp -r would dereference, breaking require() paths
main_repo_root="$(cd "$(git rev-parse --git-common-dir 2>/dev/null)/.." && pwd)"
if [[ -n "$main_repo_root" && -d "$main_repo_root/frontend/node_modules" ]]; then
  cp -a "$main_repo_root/frontend/node_modules" frontend/
  echo "Copied frontend/node_modules (with symlinks preserved)"
fi

# --- Allow direnv so the nix devshell activates in pane commands ---
if command -v direnv &>/dev/null && [ -f .envrc ]; then
  direnv allow
  echo "direnv allowed"
fi

# --- Create matching windmill-ee-private worktree ---
# Find ee repo: sibling to the main worktree (git toplevel of the main checkout),
# then try parent of cwd, then fall back to home
ee_repo=""
for candidate in \
  "${main_repo_root:+${main_repo_root}/../windmill-ee-private}" \
  "$(pwd)/../windmill-ee-private" \
  "${HOME}/windmill-ee-private" \
  "${HOME}/projects/windmill-ee-private"; do
  if [ -n "$candidate" ] && [ -d "$candidate" ]; then
    ee_repo="$(cd "$candidate" && pwd)"
    break
  fi
done
if [ -n "$ee_repo" ]; then
  branch=$(git branch --show-current 2>/dev/null || true)
  wt_basename=$(basename "$(pwd)")
  ee_worktree_dir="${ee_repo}__worktrees/${wt_basename}"

  if [ -n "$branch" ] && [ ! -d "$ee_worktree_dir" ]; then
    mkdir -p "$(dirname "$ee_worktree_dir")"

    # Fetch latest so we can check out remote branches
    git -C "$ee_repo" fetch --quiet 2>/dev/null || true

    # Try: existing branch, then new branch from main
    if git -C "$ee_repo" worktree add "$ee_worktree_dir" "$branch" 2>/dev/null; then
      echo "Created EE worktree at $ee_worktree_dir (branch: $branch)"
    elif git -C "$ee_repo" worktree add -b "$branch" "$ee_worktree_dir" main 2>/dev/null; then
      echo "Created EE worktree at $ee_worktree_dir (new branch: $branch from main)"
    else
      echo "Warning: Could not create EE worktree for branch $branch"
    fi
  elif [ -d "$ee_worktree_dir" ]; then
    echo "EE worktree already exists at $ee_worktree_dir"
  fi

  # Point Claude Code additionalDirectories at the EE worktree
  if [ -d "$ee_worktree_dir" ]; then
    ee_rel=$(python3 -c "import os; print(os.path.relpath('$ee_worktree_dir', '$(pwd)'))" 2>/dev/null || echo "$ee_worktree_dir")
    mkdir -p .claude
    cat > .claude/settings.local.json <<EOFCLAUDE
{
  "permissions": {
    "additionalDirectories": [
      "$ee_rel"
    ]
  }
}
EOFCLAUDE
    echo "Created .claude/settings.local.json with EE path: $ee_rel"

    # Create symlinks from backend crates to the EE worktree
    if [ -x "./backend/substitute_ee_code.sh" ]; then
      ./backend/substitute_ee_code.sh -d "$ee_worktree_dir"
    fi
  fi
fi